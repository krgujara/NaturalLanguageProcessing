<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0060)http://www.nltk.org/_modules/nltk/corpus/reader/wordnet.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <title>nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation</title>
    
    <link rel="stylesheet" href="./nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation_files/agogo.css" type="text/css">
    <link rel="stylesheet" href="./nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation_files/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="./nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation_files/jquery.js"></script>
    <script type="text/javascript" src="./nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation_files/underscore.js"></script>
    <script type="text/javascript" src="./nltk.corpus.reader.wordnet — NLTK 3.2.5 documentation_files/doctools.js"></script>
    <link rel="index" title="Index" href="http://www.nltk.org/genindex.html">
    <link rel="search" title="Search" href="http://www.nltk.org/search.html"> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a href="http://www.nltk.org/index.html">NLTK 3.2.5 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="http://www.nltk.org/py-modindex.html" title="Python Module Index">modules</a> |
          <a href="http://www.nltk.org/genindex.html" title="General Index" accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nltk.corpus.reader.wordnet</h1><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Natural Language Toolkit: WordNet</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2017 NLTK Project</span>
<span class="c1"># Author: Steven Bethard &lt;Steven.Bethard@colorado.edu&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Nitin Madnani &lt;nmadnani@ets.org&gt;</span>
<span class="c1">#         Nasruddin A’aidil Shari</span>
<span class="c1">#         Sim Wei Ying Geraldine</span>
<span class="c1">#         Soe Lynn</span>
<span class="c1">#         Francis Bond &lt;bond@ieee.org&gt;</span>
<span class="c1"># URL: &lt;http://nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">"""</span>
<span class="sd">An NLTK interface for WordNet</span>

<span class="sd">WordNet is a lexical database of English.</span>
<span class="sd">Using synsets, helps find conceptual relationships between words</span>
<span class="sd">such as hypernyms, hyponyms, synonyms, antonyms etc.</span>

<span class="sd">For details about WordNet see:</span>
<span class="sd">http://wordnet.princeton.edu/</span>

<span class="sd">This module also allows you to find lemmas in languages</span>
<span class="sd">other than English from the Open Multilingual Wordnet</span>
<span class="sd">http://compling.hss.ntu.edu.sg/omw/</span>

<span class="sd">"""</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">islice</span><span class="p">,</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">total_ordering</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>

<span class="kn">from</span> <span class="nn">nltk.corpus.reader</span> <span class="k">import</span> <span class="n">CorpusReader</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="k">import</span> <span class="n">binary_search_file</span> <span class="k">as</span> <span class="n">_binary_search_file</span>
<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="k">import</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="k">import</span> <span class="n">python_2_unicode_compatible</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="k">import</span> <span class="n">deprecated</span>

<span class="c1">######################################################################</span>
<span class="c1"># Table of Contents</span>
<span class="c1">######################################################################</span>
<span class="c1"># - Constants</span>
<span class="c1"># - Data Classes</span>
<span class="c1">#   - WordNetError</span>
<span class="c1">#   - Lemma</span>
<span class="c1">#   - Synset</span>
<span class="c1"># - WordNet Corpus Reader</span>
<span class="c1"># - WordNet Information Content Corpus Reader</span>
<span class="c1"># - Similarity Metrics</span>
<span class="c1"># - Demo</span>

<span class="c1">######################################################################</span>
<span class="c1"># Constants</span>
<span class="c1">######################################################################</span>

<span class="c1">#: Positive infinity (for similarity functions)</span>
<span class="n">_INF</span> <span class="o">=</span> <span class="mf">1e300</span>

<span class="c1"># { Part-of-speech constants</span>
<span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s1">'a'</span><span class="p">,</span> <span class="s1">'s'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">,</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span>
<span class="c1"># }</span>

<span class="n">POS_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADV</span><span class="p">]</span>

<span class="c1"># A table of strings that are used to express verb frames.</span>
<span class="n">VERB_FRAME_STRINGS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="kc">None</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span>
    <span class="s2">"It is </span><span class="si">%s</span><span class="s2">ing"</span><span class="p">,</span>
    <span class="s2">"Something is </span><span class="si">%s</span><span class="s2">ing PP"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> something Adjective/Noun"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> Adjective/Noun"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> Adjective"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> somebody"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> something"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> to somebody"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> on something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something to somebody"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something from somebody"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody with something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody of something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something on somebody"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody PP"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something PP"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> PP"</span><span class="p">,</span>
    <span class="s2">"Somebody's (body part) </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody to INFINITIVE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody INFINITIVE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> that CLAUSE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> to somebody"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> to INFINITIVE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> whether INFINITIVE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> somebody into V-ing something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> something with something"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> INFINITIVE"</span><span class="p">,</span>
    <span class="s2">"Somebody </span><span class="si">%s</span><span class="s2"> VERB-ing"</span><span class="p">,</span>
    <span class="s2">"It </span><span class="si">%s</span><span class="s2"> that CLAUSE"</span><span class="p">,</span>
    <span class="s2">"Something </span><span class="si">%s</span><span class="s2"> INFINITIVE"</span><span class="p">)</span>

<span class="n">SENSENUM_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">'\.[\d]+\.'</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># Data Classes</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="WordNetError"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetError">[docs]</a><span class="k">class</span> <span class="nc">WordNetError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">"""An exception class for wordnet-related errors."""</span></div>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">_WordNetObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""A common base class for lemmas and synsets."""</span>

    <span class="k">def</span> <span class="nf">hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'@'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'@'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'@i'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_instance_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'@i'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'~'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'~i'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'#m'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'#s'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'#p'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'%m'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'%p'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">topic_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">';c'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">region_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">';r'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">usage_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">';u'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'='</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entailments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">causes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'&gt;'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">also_sees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'^'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verb_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'$'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">similar_tos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'&amp;'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>


<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Lemma"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma">[docs]</a><span class="k">class</span> <span class="nc">Lemma</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    The lexical entry for a single morphological form of a</span>
<span class="sd">    sense-disambiguated word.</span>

<span class="sd">    Create a Lemma from a "&lt;word&gt;.&lt;pos&gt;.&lt;number&gt;.&lt;lemma&gt;" string where:</span>
<span class="sd">    &lt;word&gt; is the morphological stem identifying the synset</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>
<span class="sd">    &lt;lemma&gt; is the morphological form of interest</span>

<span class="sd">    Note that &lt;word&gt; and &lt;lemma&gt; can be different, e.g. the Synset</span>
<span class="sd">    'salt.n.03' has the Lemmas 'salt.n.03.salt', 'salt.n.03.saltiness' and</span>
<span class="sd">    'salt.n.03.salinity'.</span>

<span class="sd">    Lemma attributes, accessible via methods with the same name::</span>

<span class="sd">    - name: The canonical name of this lemma.</span>
<span class="sd">    - synset: The synset that this lemma belongs to.</span>
<span class="sd">    - syntactic_marker: For adjectives, the WordNet string identifying the</span>
<span class="sd">      syntactic position relative modified noun. See:</span>
<span class="sd">      http://wordnet.princeton.edu/man/wninput.5WN.html#sect10</span>
<span class="sd">      For all other parts of speech, this attribute is None.</span>
<span class="sd">    - count: The frequency of this lemma in wordnet.</span>

<span class="sd">    Lemma methods:</span>

<span class="sd">    Lemmas have the following methods for retrieving related Lemmas. They</span>
<span class="sd">    correspond to the names for the pointer symbols defined here:</span>
<span class="sd">    http://wordnet.princeton.edu/man/wninput.5WN.html#sect3</span>
<span class="sd">    These methods all return lists of Lemmas:</span>

<span class="sd">    - antonyms</span>
<span class="sd">    - hypernyms, instance_hypernyms</span>
<span class="sd">    - hyponyms, instance_hyponyms</span>
<span class="sd">    - member_holonyms, substance_holonyms, part_holonyms</span>
<span class="sd">    - member_meronyms, substance_meronyms, part_meronyms</span>
<span class="sd">    - topic_domains, region_domains, usage_domains</span>
<span class="sd">    - attributes</span>
<span class="sd">    - derivationally_related_forms</span>
<span class="sd">    - entailments</span>
<span class="sd">    - causes</span>
<span class="sd">    - also_sees</span>
<span class="sd">    - verb_groups</span>
<span class="sd">    - similar_tos</span>
<span class="sd">    - pertainyms</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'_wordnet_corpus_reader'</span><span class="p">,</span> <span class="s1">'_name'</span><span class="p">,</span> <span class="s1">'_syntactic_marker'</span><span class="p">,</span>
                 <span class="s1">'_synset'</span><span class="p">,</span> <span class="s1">'_frame_strings'</span><span class="p">,</span> <span class="s1">'_frame_ids'</span><span class="p">,</span>
                 <span class="s1">'_lexname_index'</span><span class="p">,</span> <span class="s1">'_lex_id'</span><span class="p">,</span> <span class="s1">'_lang'</span><span class="p">,</span> <span class="s1">'_key'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordnet_corpus_reader</span><span class="p">,</span> <span class="n">synset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                 <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">syntactic_marker</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntactic_marker</span> <span class="o">=</span> <span class="n">syntactic_marker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexname_index</span> <span class="o">=</span> <span class="n">lexname_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lex_id</span> <span class="o">=</span> <span class="n">lex_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang</span> <span class="o">=</span> <span class="s1">'eng'</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># gets set later.</span>

<div class="viewcode-block" id="Lemma.name"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span></div>

<div class="viewcode-block" id="Lemma.syntactic_marker"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.syntactic_marker">[docs]</a>    <span class="k">def</span> <span class="nf">syntactic_marker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_syntactic_marker</span></div>

<div class="viewcode-block" id="Lemma.synset"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.synset">[docs]</a>    <span class="k">def</span> <span class="nf">synset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span></div>

<div class="viewcode-block" id="Lemma.frame_strings"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.frame_strings">[docs]</a>    <span class="k">def</span> <span class="nf">frame_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_strings</span></div>

<div class="viewcode-block" id="Lemma.frame_ids"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.frame_ids">[docs]</a>    <span class="k">def</span> <span class="nf">frame_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span></div>

<div class="viewcode-block" id="Lemma.lang"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.lang">[docs]</a>    <span class="k">def</span> <span class="nf">lang</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang</span></div>

<div class="viewcode-block" id="Lemma.key"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.key">[docs]</a>    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">return</span> <span class="s2">"</span><span class="si">%s</span><span class="s2">('</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">')"</span> <span class="o">%</span> <span class="n">tup</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span>
            <span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">lemma_index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">lemma_index</span>
            <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span><span class="o">.</span><span class="n">_lemma_pointers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">]</span>
        <span class="p">])</span>

<div class="viewcode-block" id="Lemma.count"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the frequency count for this Lemma"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.antonyms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.antonyms">[docs]</a>    <span class="k">def</span> <span class="nf">antonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'!'</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.derivationally_related_forms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.derivationally_related_forms">[docs]</a>    <span class="k">def</span> <span class="nf">derivationally_related_forms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'+'</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.pertainyms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Lemma.pertainyms">[docs]</a>    <span class="k">def</span> <span class="nf">pertainyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">)</span></div></div>


<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Synset"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset">[docs]</a><span class="k">class</span> <span class="nc">Synset</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">"""Create a Synset from a "&lt;lemma&gt;.&lt;pos&gt;.&lt;number&gt;" string where:</span>
<span class="sd">    &lt;lemma&gt; is the word's morphological stem</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>

<span class="sd">    Synset attributes, accessible via methods with the same name:</span>

<span class="sd">    - name: The canonical name of this synset, formed using the first lemma</span>
<span class="sd">      of this synset. Note that this may be different from the name</span>
<span class="sd">      passed to the constructor if that string used a different lemma to</span>
<span class="sd">      identify the synset.</span>
<span class="sd">    - pos: The synset's part of speech, matching one of the module level</span>
<span class="sd">      attributes ADJ, ADJ_SAT, ADV, NOUN or VERB.</span>
<span class="sd">    - lemmas: A list of the Lemma objects for this synset.</span>
<span class="sd">    - definition: The definition for this synset.</span>
<span class="sd">    - examples: A list of example strings for this synset.</span>
<span class="sd">    - offset: The offset in the WordNet dict file of this synset.</span>
<span class="sd">    - lexname: The name of the lexicographer file containing this synset.</span>

<span class="sd">    Synset methods:</span>

<span class="sd">    Synsets have the following methods for retrieving related Synsets.</span>
<span class="sd">    They correspond to the names for the pointer symbols defined here:</span>
<span class="sd">    http://wordnet.princeton.edu/man/wninput.5WN.html#sect3</span>
<span class="sd">    These methods all return lists of Synsets.</span>

<span class="sd">    - hypernyms, instance_hypernyms</span>
<span class="sd">    - hyponyms, instance_hyponyms</span>
<span class="sd">    - member_holonyms, substance_holonyms, part_holonyms</span>
<span class="sd">    - member_meronyms, substance_meronyms, part_meronyms</span>
<span class="sd">    - attributes</span>
<span class="sd">    - entailments</span>
<span class="sd">    - causes</span>
<span class="sd">    - also_sees</span>
<span class="sd">    - verb_groups</span>
<span class="sd">    - similar_tos</span>

<span class="sd">    Additionally, Synsets support the following methods specific to the</span>
<span class="sd">    hypernym relation:</span>

<span class="sd">    - root_hypernyms</span>
<span class="sd">    - common_hypernyms</span>
<span class="sd">    - lowest_common_hypernyms</span>

<span class="sd">    Note that Synsets do not support the following relations because</span>
<span class="sd">    these are defined by WordNet as lexical relations:</span>

<span class="sd">    - antonyms</span>
<span class="sd">    - derivationally_related_forms</span>
<span class="sd">    - pertainyms</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'_pos'</span><span class="p">,</span> <span class="s1">'_offset'</span><span class="p">,</span> <span class="s1">'_name'</span><span class="p">,</span> <span class="s1">'_frame_ids'</span><span class="p">,</span>
                 <span class="s1">'_lemmas'</span><span class="p">,</span> <span class="s1">'_lemma_names'</span><span class="p">,</span>
                 <span class="s1">'_definition'</span><span class="p">,</span> <span class="s1">'_examples'</span><span class="p">,</span> <span class="s1">'_lexname'</span><span class="p">,</span>
                 <span class="s1">'_pointers'</span><span class="p">,</span> <span class="s1">'_lemma_pointers'</span><span class="p">,</span> <span class="s1">'_max_depth'</span><span class="p">,</span>
                 <span class="s1">'_min_depth'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordnet_corpus_reader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="c1"># All of these attributes get initialized by</span>
        <span class="c1"># WordNetCorpusReader._synset_from_pos_and_line()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_definition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_examples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexname</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># lexicographer name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

<div class="viewcode-block" id="Synset.pos"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.pos">[docs]</a>    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span></div>

<div class="viewcode-block" id="Synset.offset"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.offset">[docs]</a>    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span></div>

<div class="viewcode-block" id="Synset.name"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span></div>

<div class="viewcode-block" id="Synset.frame_ids"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.frame_ids">[docs]</a>    <span class="k">def</span> <span class="nf">frame_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span></div>

<div class="viewcode-block" id="Synset.definition"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.definition">[docs]</a>    <span class="k">def</span> <span class="nf">definition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_definition</span></div>

<div class="viewcode-block" id="Synset.examples"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.examples">[docs]</a>    <span class="k">def</span> <span class="nf">examples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_examples</span></div>

<div class="viewcode-block" id="Synset.lexname"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lexname">[docs]</a>    <span class="k">def</span> <span class="nf">lexname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexname</span></div>

    <span class="k">def</span> <span class="nf">_needs_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">NOUN</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'1.6'</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">VERB</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Synset.lemma_names"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lemma_names">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">'''Return all the lemma_names associated with the synset'''</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">ss2of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Synset.lemmas"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">'''Return all the lemma objects associated with the synset'''</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemmas</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemmark</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lemmy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemma_names</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lem</span> <span class="ow">in</span> <span class="n">lemmy</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">Lemma</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">lem</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_lexnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lexname</span><span class="p">()</span>
                    <span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="kc">None</span>
                <span class="p">)</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">_lang</span> <span class="o">=</span> <span class="n">lang</span>
                <span class="n">lemmark</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lemmark</span></div>

<div class="viewcode-block" id="Synset.root_hypernyms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.root_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">root_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Get the topmost hypernyms of this synset in WordNet."""</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">next_synset</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_synset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="n">next_hypernyms</span> <span class="o">=</span> <span class="n">next_synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> \
                    <span class="n">next_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">next_hypernyms</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">todo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">next_hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<span class="c1"># Simpler implementation which makes incorrect assumption that</span>
<span class="c1"># hypernym hierarchy is acyclic:</span>
<span class="c1">#</span>
<span class="c1">#        if not self.hypernyms():</span>
<span class="c1">#            return [self]</span>
<span class="c1">#        else:</span>
<span class="c1">#            return list(set(root for h in self.hypernyms()</span>
<span class="c1">#                            for root in h.root_hypernyms()))</span>
<div class="viewcode-block" id="Synset.max_depth"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.max_depth">[docs]</a>    <span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :return: The length of the longest hypernym path from this</span>
<span class="sd">        synset to the root.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="s2">"_max_depth"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span></div>

<div class="viewcode-block" id="Synset.min_depth"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.min_depth">[docs]</a>    <span class="k">def</span> <span class="nf">min_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :return: The length of the shortest hypernym path from this</span>
<span class="sd">        synset to the root.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="s2">"_min_depth"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span></div>

<div class="viewcode-block" id="Synset.closure"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.closure">[docs]</a>    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">"""Return the transitive closure of source under the rel</span>
<span class="sd">        relationship, breadth-first</span>

<span class="sd">            &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">            &gt;&gt;&gt; dog = wn.synset('dog.n.01')</span>
<span class="sd">            &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">            &gt;&gt;&gt; list(dog.closure(hyp))</span>
<span class="sd">            [Synset('canine.n.02'), Synset('domestic_animal.n.01'),</span>
<span class="sd">            Synset('carnivore.n.01'), Synset('animal.n.01'),</span>
<span class="sd">            Synset('placental.n.01'), Synset('organism.n.01'),</span>
<span class="sd">            Synset('mammal.n.01'), Synset('living_thing.n.01'),</span>
<span class="sd">            Synset('vertebrate.n.01'), Synset('whole.n.02'),</span>
<span class="sd">            Synset('chordate.n.01'), Synset('object.n.01'),</span>
<span class="sd">            Synset('physical_entity.n.01'), Synset('entity.n.01')]</span>

<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="k">import</span> <span class="n">breadth_first</span>
        <span class="n">synset_offsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">breadth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">synset_offsets</span><span class="p">:</span>
                    <span class="n">synset_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">synset</span></div>

<div class="viewcode-block" id="Synset.hypernym_paths"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.hypernym_paths">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the path(s) from this synset to the root, where each path is a</span>
<span class="sd">        list of the synset nodes traversed on the way to the root.</span>

<span class="sd">        :return: A list of lists, where each list gives the node sequence</span>
<span class="sd">           connecting the initial ``Synset`` node and a root node.</span>
<span class="sd">        """</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypernyms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ancestor_list</span> <span class="ow">in</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_paths</span><span class="p">():</span>
                <span class="n">ancestor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ancestor_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span></div>

<div class="viewcode-block" id="Synset.common_hypernyms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">common_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Find all synsets that are hypernyms of this synset and the</span>
<span class="sd">        other synset.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: other input synset.</span>
<span class="sd">        :return: The synsets that are hypernyms of both synsets.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">self_synset</span>
                <span class="k">for</span> <span class="n">self_synsets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">self_synset</span> <span class="ow">in</span> <span class="n">self_synsets</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">other_synset</span>
                <span class="k">for</span> <span class="n">other_synsets</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">other_synset</span> <span class="ow">in</span> <span class="n">other_synsets</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">))</span></div>

<div class="viewcode-block" id="Synset.lowest_common_hypernyms"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lowest_common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">lowest_common_hypernyms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_depth</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get a list of lowest synset(s) that both synsets have as a hypernym.</span>
<span class="sd">        When `use_min_depth == False` this means that the synset which appears</span>
<span class="sd">        as a hypernym of both `self` and `other` with the lowest maximum depth</span>
<span class="sd">        is returned or if there are multiple such synsets at the same depth</span>
<span class="sd">        they are all returned</span>

<span class="sd">        However, if `use_min_depth == True` then the synset(s) which has/have</span>
<span class="sd">        the lowest minimum depth and appear(s) in both paths is/are returned.</span>

<span class="sd">        By setting the use_min_depth flag to True, the behavior of NLTK2 can be</span>
<span class="sd">        preserved. This was changed in NLTK3 to give more accurate results in a</span>
<span class="sd">        small set of cases, generally with synsets concerning people. (eg:</span>
<span class="sd">        'chef.n.01', 'fireman.n.01', etc.)</span>

<span class="sd">        This method is an implementation of Ted Pedersen's "Lowest Common</span>
<span class="sd">        Subsumer" method from the Perl Wordnet module. It can return either</span>
<span class="sd">        "self" or "other" if they are a hypernym of the other.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: other input synset</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (False by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to True to enable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will need to be added</span>
<span class="sd">            for nouns as well.</span>
<span class="sd">        :type use_min_depth: bool</span>
<span class="sd">        :param use_min_depth: This setting mimics older (v2) behavior of NLTK</span>
<span class="sd">            wordnet If True, will use the min_depth function to calculate the</span>
<span class="sd">            lowest common hypernyms. This is known to give strange results for</span>
<span class="sd">            some synset pairs (eg: 'chef.n.01', 'fireman.n.01') but is retained</span>
<span class="sd">            for backwards compatibility</span>
<span class="sd">        :return: The synsets that are the lowest common hypernyms of both</span>
<span class="sd">            synsets</span>
<span class="sd">        """</span>
        <span class="n">synsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'*ROOT*'</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
            <span class="n">synsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fake_synset</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_min_depth</span><span class="p">:</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
                <span class="n">unsorted_lch</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_depth</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
                <span class="n">unsorted_lch</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_depth</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_lch</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Synset.hypernym_distances"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.hypernym_distances">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get the path(s) from this synset to the root, counting the distance</span>
<span class="sd">        of each node from the initial node on the way. A set of</span>
<span class="sd">        (synset, distance) tuples is returned.</span>

<span class="sd">        :type distance: int</span>
<span class="sd">        :param distance: the distance (number of edges) from this hypernym to</span>
<span class="sd">            the original hypernym ``Synset`` on which this method was called.</span>
<span class="sd">        :return: A set of ``(Synset, int)`` tuples where each ``Synset`` is</span>
<span class="sd">           a hypernym of the first ``Synset``.</span>
<span class="sd">        """</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_hypernyms</span><span class="p">():</span>
            <span class="n">distances</span> <span class="o">|=</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_distances</span><span class="p">(</span>
                <span class="n">distance</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'*ROOT*'</span>
            <span class="n">fake_synset_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">fake_synset</span><span class="p">,</span> <span class="n">fake_synset_distance</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">distances</span></div>

    <span class="k">def</span> <span class="nf">_shortest_hypernym_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s1">'*ROOT*'</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">path</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>

            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">hyp</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">_hypernyms</span><span class="p">())</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">hyp</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">_instance_hypernyms</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'*ROOT*'</span>
            <span class="n">path</span><span class="p">[</span><span class="n">fake_synset</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="Synset.shortest_path_distance"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.shortest_path_distance">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the distance of the shortest path linking the two synsets (if</span>
<span class="sd">        one exists). For each synset, all the ancestor nodes and their</span>
<span class="sd">        distances are recorded and compared. The ancestor node common to both</span>
<span class="sd">        synsets that can be reached with the minimum number of traversals is</span>
<span class="sd">        used. If no ancestor nodes are common, None is returned. If a node is</span>
<span class="sd">        compared with itself 0 is returned.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The Synset to which the shortest path will be found.</span>
<span class="sd">        :return: The number of edges in the shortest path connecting the two</span>
<span class="sd">            nodes, or None if no path exists.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">dist_dict1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shortest_hypernym_paths</span><span class="p">(</span><span class="n">simulate_root</span><span class="p">)</span>
        <span class="n">dist_dict2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_shortest_hypernym_paths</span><span class="p">(</span><span class="n">simulate_root</span><span class="p">)</span>

        <span class="c1"># For each ancestor synset common to both subject synsets, find the</span>
        <span class="c1"># connecting path length. Return the shortest of these.</span>

        <span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>
        <span class="n">path_distance</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="k">for</span> <span class="n">synset</span><span class="p">,</span> <span class="n">d1</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dist_dict1</span><span class="p">):</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">dist_dict2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">synset</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
            <span class="n">path_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_distance</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">path_distance</span><span class="p">)</span> <span class="k">else</span> <span class="n">path_distance</span></div>

<div class="viewcode-block" id="Synset.tree"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.tree">[docs]</a>    <span class="k">def</span> <span class="nf">tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cut_mark</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; dog = wn.synset('dog.n.01')</span>
<span class="sd">        &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">        &gt;&gt;&gt; from pprint import pprint</span>
<span class="sd">        &gt;&gt;&gt; pprint(dog.tree(hyp))</span>
<span class="sd">        [Synset('dog.n.01'),</span>
<span class="sd">         [Synset('canine.n.02'),</span>
<span class="sd">          [Synset('carnivore.n.01'),</span>
<span class="sd">           [Synset('placental.n.01'),</span>
<span class="sd">            [Synset('mammal.n.01'),</span>
<span class="sd">             [Synset('vertebrate.n.01'),</span>
<span class="sd">              [Synset('chordate.n.01'),</span>
<span class="sd">               [Synset('animal.n.01'),</span>
<span class="sd">                [Synset('organism.n.01'),</span>
<span class="sd">                 [Synset('living_thing.n.01'),</span>
<span class="sd">                  [Synset('whole.n.02'),</span>
<span class="sd">                   [Synset('object.n.01'),</span>
<span class="sd">                    [Synset('physical_entity.n.01'),</span>
<span class="sd">                     [Synset('entity.n.01')]]]]]]]]]]]]],</span>
<span class="sd">         [Synset('domestic_animal.n.01'),</span>
<span class="sd">          [Synset('animal.n.01'),</span>
<span class="sd">           [Synset('organism.n.01'),</span>
<span class="sd">            [Synset('living_thing.n.01'),</span>
<span class="sd">             [Synset('whole.n.02'),</span>
<span class="sd">              [Synset('object.n.01'),</span>
<span class="sd">               [Synset('physical_entity.n.01'), [Synset('entity.n.01')]]]]]]]]]</span>
<span class="sd">        """</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">tree</span><span class="p">(</span><span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cut_mark</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rel</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">cut_mark</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cut_mark</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tree</span></div>

    <span class="c1"># interface to similarity methods</span>
<div class="viewcode-block" id="Synset.path_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Path Distance Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses in the is-a (hypernym/hypnoym)</span>
<span class="sd">        taxonomy. The score is in the range 0 to 1, except in those cases where</span>
<span class="sd">        a path cannot be found (will only be true for verbs as there are many</span>
<span class="sd">        distinct verb taxonomies), in which case None is returned. A score of</span>
<span class="sd">        1 represents identity i.e. comparing a sense with itself will return 1.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A score denoting the similarity of the two ``Synset`` objects,</span>
<span class="sd">            normally between 0 and 1. None is returned if no connecting path</span>
<span class="sd">            could be found. 1 is returned if a ``Synset`` is compared with</span>
<span class="sd">            itself.</span>
<span class="sd">        """</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.lch_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Leacock Chodorow Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses (as above) and the maximum depth</span>
<span class="sd">        of the taxonomy in which the senses occur. The relationship is given as</span>
<span class="sd">        -log(p/2d) where p is the shortest path length and d is the taxonomy</span>
<span class="sd">        depth.</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A score denoting the similarity of the two ``Synset`` objects,</span>
<span class="sd">            normally greater than 0. None is returned if no connecting path</span>
<span class="sd">            could be found. If a ``Synset`` is compared with itself, the</span>
<span class="sd">            maximum score is returned, which varies depending on the taxonomy</span>
<span class="sd">            depth.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
                <span class="s1">'Computing the lch similarity requires '</span>
                <span class="s1">'</span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1"> to have the same part of speech.'</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_compute_max_depth</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">need_root</span>
            <span class="p">)</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">))</span></div>

<div class="viewcode-block" id="Synset.wup_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Wu-Palmer Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        depth of the two senses in the taxonomy and that of their Least Common</span>
<span class="sd">        Subsumer (most specific ancestor node). Previously, the scores computed</span>
<span class="sd">        by this implementation did _not_ always agree with those given by</span>
<span class="sd">        Pedersen's Perl implementation of WordNet Similarity. However, with</span>
<span class="sd">        the addition of the simulate_root flag (see below), the score for</span>
<span class="sd">        verbs now almost always agree but not always for nouns.</span>

<span class="sd">        The LCS does not necessarily feature in the shortest path connecting</span>
<span class="sd">        the two senses, as it is by definition the common ancestor deepest in</span>
<span class="sd">        the taxonomy, not closest to the two senses. Typically, however, it</span>
<span class="sd">        will so feature. Where multiple candidates for the LCS exist, that</span>
<span class="sd">        whose shortest path to the root node is the longest will be selected.</span>
<span class="sd">        Where the LCS has multiple paths to the root, the longer path is used</span>
<span class="sd">        for the purposes of the calculation.</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects, normally greater than zero. If no connecting path between</span>
<span class="sd">            the two senses can be found, None is returned.</span>

<span class="sd">        """</span>

        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>
        <span class="c1"># Note that to preserve behavior from NLTK2 we set use_min_depth=True</span>
        <span class="c1"># It is possible that more accurate results could be obtained by</span>
        <span class="c1"># removing this setting and it should be tested later on</span>
        <span class="n">subsumers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowest_common_hypernyms</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">,</span> <span class="n">use_min_depth</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># If no LCS was found return None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">subsumer</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">subsumers</span> <span class="k">else</span> <span class="n">subsumers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the longest path from the LCS to the root,</span>
        <span class="c1"># including a correction:</span>
        <span class="c1"># - add one because the calculations include both the start and end</span>
        <span class="c1">#   nodes</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">subsumer</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Note: No need for an additional add-one correction for non-nouns</span>
        <span class="c1"># to account for an imaginary root node because that is now</span>
        <span class="c1"># automatically handled by simulate_root</span>
        <span class="c1"># if subsumer._pos != NOUN:</span>
        <span class="c1">#     depth += 1</span>

        <span class="c1"># Get the shortest path from the LCS to each of the synsets it is</span>
        <span class="c1"># subsuming.  Add this to the LCS path length to get the path</span>
        <span class="c1"># length from each synset to the root.</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">subsumer</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>
        <span class="n">len2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">subsumer</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">len1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">len2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">len1</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="n">len2</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.res_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Resnik Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node).</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects. Synsets whose LCS is the root node of the taxonomy will</span>
<span class="sd">            have a score of 0 (e.g. N['dog'][0] and N['table'][0]).</span>
<span class="sd">        """</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lcs_ic</span></div>

<div class="viewcode-block" id="Synset.jcn_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Jiang-Conrath Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 1 / (IC(s1) + IC(s2) - 2 * IC(lcs)).</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type  ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>

        <span class="c1"># If either of the input synsets are the root synset, or have a</span>
        <span class="c1"># frequency of 0 (sparse data problem), return 0.</span>
        <span class="k">if</span> <span class="n">ic1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ic2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">ic_difference</span> <span class="o">=</span> <span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lcs_ic</span>

        <span class="k">if</span> <span class="n">ic_difference</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ic_difference</span></div>

<div class="viewcode-block" id="Synset.lin_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.Synset.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Lin Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 2 * IC(lcs) / (IC(s1) + IC(s2)).</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects, in the range 0 to 1.</span>
<span class="sd">        """</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">lcs_ic</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_iter_hypernym_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :return: An iterator over ``Synset`` objects that are either proper</span>
<span class="sd">        hypernyms or instance of hypernyms of the synset.</span>
<span class="sd">        """</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synset</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">todo</span>
            <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="n">hypernym</span>
                    <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span>
                    <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="n">synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">hypernym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"</span><span class="si">%s</span><span class="s2">('</span><span class="si">%s</span><span class="s2">')"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
        <span class="n">pointer_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">relation_symbol</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">pointer_tuples</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">r</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># WordNet Corpus Reader</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A corpus reader used to access wordnet or its variants.</span>
<span class="sd">    """</span>

    <span class="n">_ENCODING</span> <span class="o">=</span> <span class="s1">'utf8'</span>

    <span class="c1"># { Part-of-speech constants</span>
    <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s1">'a'</span><span class="p">,</span> <span class="s1">'s'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">,</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span>
    <span class="c1"># }</span>

    <span class="c1"># { Filename constants</span>
    <span class="n">_FILEMAP</span> <span class="o">=</span> <span class="p">{</span><span class="n">ADJ</span><span class="p">:</span> <span class="s1">'adj'</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="s1">'adv'</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">:</span> <span class="s1">'noun'</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="s1">'verb'</span><span class="p">}</span>
    <span class="c1"># }</span>

    <span class="c1"># { Part of speech constants</span>
    <span class="n">_pos_numbers</span> <span class="o">=</span> <span class="p">{</span><span class="n">NOUN</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="n">_pos_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">_pos_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="c1"># }</span>

    <span class="c1">#: A list of file identifiers for all the fileids used by this</span>
    <span class="c1">#: corpus reader.</span>
    <span class="n">_FILES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'cntlist.rev'</span><span class="p">,</span> <span class="s1">'lexnames'</span><span class="p">,</span> <span class="s1">'index.sense'</span><span class="p">,</span>
              <span class="s1">'index.adj'</span><span class="p">,</span> <span class="s1">'index.adv'</span><span class="p">,</span> <span class="s1">'index.noun'</span><span class="p">,</span> <span class="s1">'index.verb'</span><span class="p">,</span>
              <span class="s1">'data.adj'</span><span class="p">,</span> <span class="s1">'data.adv'</span><span class="p">,</span> <span class="s1">'data.noun'</span><span class="p">,</span> <span class="s1">'data.verb'</span><span class="p">,</span>
              <span class="s1">'adj.exc'</span><span class="p">,</span> <span class="s1">'adv.exc'</span><span class="p">,</span> <span class="s1">'noun.exc'</span><span class="p">,</span> <span class="s1">'verb.exc'</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">omw_reader</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct a new wordnet corpus reader, with the given root</span>
<span class="sd">        directory.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WordNetCorpusReader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILES</span><span class="p">,</span>
                                                  <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ENCODING</span><span class="p">)</span>

        <span class="c1"># A index that provides the file offset</span>
        <span class="c1"># Map from lemma -&gt; pos -&gt; synset_index -&gt; offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># A cache so we don't have to reconstuct synsets</span>
        <span class="c1"># Map from pos -&gt; offset -&gt; synset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># A lookup for the maximum depth of each part of speech.  Useful for</span>
        <span class="c1"># the lch similarity metric.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Corpus reader containing omw data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span> <span class="o">=</span> <span class="n">omw_reader</span>

        <span class="c1"># A cache to store the wordnet data of multiple languages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Load the lexnames</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'lexnames'</span><span class="p">)):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">lexname</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lexname</span><span class="p">)</span>

        <span class="c1"># Load the indices for lemmas and synset offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_lemma_pos_offset_map</span><span class="p">()</span>

        <span class="c1"># load the exception file data into memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_exception_map</span><span class="p">()</span>

<span class="c1"># Open Multilingual WordNet functions, contributed by</span>
<span class="c1"># Nasruddin A’aidil Shari, Sim Wei Ying Geraldine, and Soe Lynn</span>

<div class="viewcode-block" id="WordNetCorpusReader.of2ss"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.of2ss">[docs]</a>    <span class="k">def</span> <span class="nf">of2ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">of</span><span class="p">):</span>
        <span class="sd">''' take an id and return the synsets '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">of</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">of</span><span class="p">[:</span><span class="mi">8</span><span class="p">]))</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.ss2of"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.ss2of">[docs]</a>    <span class="k">def</span> <span class="nf">ss2of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
        <span class="sd">''' return the ID of the synset '''</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"</span><span class="si">{:08d}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">offset</span><span class="p">(),</span> <span class="n">ss</span><span class="o">.</span><span class="n">pos</span><span class="p">()))</span></div>

    <span class="k">def</span> <span class="nf">_load_lang_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="p">):</span>
        <span class="sd">''' load the wordnet data of the requested language from the file to</span>
<span class="sd">        the cache, _lang_data '''</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"Language is not supported."</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'</span><span class="si">{0:}</span><span class="s1">/wn-data-</span><span class="si">{0:}</span><span class="s1">.tab'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lang</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_lemmas</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lang</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="WordNetCorpusReader.langs"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.langs">[docs]</a>    <span class="k">def</span> <span class="nf">langs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">''' return a list of languages supported by Multilingual Wordnet '''</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="n">langs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'eng'</span><span class="p">]</span>
        <span class="n">fileids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">fileids</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fileid</span> <span class="ow">in</span> <span class="n">fileids</span><span class="p">:</span>
            <span class="n">file_name</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_extension</span> <span class="o">==</span> <span class="s1">'.tab'</span><span class="p">:</span>
                <span class="n">langs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'-'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">langs</span></div>

    <span class="k">def</span> <span class="nf">_load_lemma_pos_offset_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="c1"># parse each line of the file (ignoring comment lines)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'index.</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">' '</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

                <span class="k">def</span> <span class="nf">_next_token</span><span class="p">():</span> <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>

                    <span class="c1"># get the lemma and part-of-speech</span>
                    <span class="n">lemma</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>

                    <span class="c1"># get the number of synsets for this lemma</span>
                    <span class="n">n_synsets</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                    <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">&gt;</span> <span class="mi">0</span>

                    <span class="c1"># get and ignore the pointer symbols for all synsets of</span>
                    <span class="c1"># this lemma</span>
                    <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                    <span class="p">[</span><span class="n">_next_token</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">)]</span>

                    <span class="c1"># same as number of synsets</span>
                    <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                    <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">==</span> <span class="n">n_senses</span>

                    <span class="c1"># get and ignore number of senses ranked according to</span>
                    <span class="c1"># frequency</span>
                    <span class="n">_next_token</span><span class="p">()</span>

                    <span class="c1"># get synset offsets</span>
                    <span class="n">synset_offsets</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synsets</span><span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># raise more informative error with file name and line number</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'index.</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">e</span>
                    <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s1">'file </span><span class="si">%s</span><span class="s1">, line </span><span class="si">%i</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span>

                <span class="c1"># map lemmas and parts of speech to synsets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>

    <span class="k">def</span> <span class="nf">_load_exception_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># load the exception file data into memory</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">.exc'</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">):</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute the max depth for the given part of speech.  This is</span>
<span class="sd">        used by the lch similarity metric.</span>
<span class="sd">        """</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">max_depth</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>

<div class="viewcode-block" id="WordNetCorpusReader.get_version"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.get_version">[docs]</a>    <span class="k">def</span> <span class="nf">get_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">ADJ</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">'WordNet (\d+\.\d+) Copyright'</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">version</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">version</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Loading Lemmas</span>
    <span class="c1">#############################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader.lemma"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma">[docs]</a>    <span class="k">def</span> <span class="nf">lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">'''Return lemma object that matches the name'''</span>
        <span class="c1"># cannot simply split on first '.',</span>
        <span class="c1"># e.g.: '.45_caliber.a.01..45_caliber'</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="n">SENSENUM_RE</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="n">leadingZero</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">separator</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leadingZero</span><span class="p">):</span>
            <span class="n">synset_name</span><span class="p">,</span> <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="n">separator</span><span class="o">+</span><span class="mi">3</span><span class="p">],</span> <span class="n">name</span><span class="p">[</span><span class="n">separator</span><span class="o">+</span><span class="mi">4</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synset_name</span><span class="p">,</span> <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="n">separator</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">name</span><span class="p">[</span><span class="n">separator</span><span class="o">+</span><span class="mi">3</span><span class="p">:]</span>
        
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset</span><span class="p">(</span><span class="n">synset_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">lemma_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s1">'no lemma </span><span class="si">%r</span><span class="s1"> in </span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">lemma_name</span><span class="p">,</span> <span class="n">synset_name</span><span class="p">))</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.lemma_from_key"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma_from_key">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_from_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># Keys are case sensitive and always lower-case</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lex_sense</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'%'</span><span class="p">)</span>
        <span class="n">pos_number</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lex_sense</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">pos_number</span><span class="p">)]</span>

        <span class="c1"># open the key -&gt; synset file if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'index.sense'</span><span class="p">)</span>

        <span class="c1"># Find the synset for the lemma.</span>
        <span class="n">synset_line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">synset_line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"No synset found for key </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c1"># return the corresponding lemma</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"No lemma found for for key </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Loading Synsets</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.synset"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.synset">[docs]</a>    <span class="k">def</span> <span class="nf">synset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># split name into lemma, part of speech and synset number</span>
        <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">synset_index_str</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">'.'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">synset_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_index_str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># get the offset for this synset</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">][</span><span class="n">synset_index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">'no lemma </span><span class="si">%r</span><span class="s1"> with part of speech </span><span class="si">%r</span><span class="s1">'</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">"lemma </span><span class="si">%r</span><span class="s2"> with part of speech </span><span class="si">%r</span><span class="s2"> has only </span><span class="si">%i</span><span class="s2"> </span><span class="si">%s</span><span class="s2">"</span>
            <span class="k">if</span> <span class="n">n_senses</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n_senses</span><span class="p">,</span> <span class="s2">"sense"</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n_senses</span><span class="p">,</span> <span class="s2">"senses"</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span>

        <span class="c1"># load synset information from the appropriate file</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c1"># some basic sanity checks on loaded attributes</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s1">'s'</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="s1">'a'</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'adjective satellite requested but only plain '</span>
                       <span class="s1">'adjective found for lemma </span><span class="si">%r</span><span class="s1">'</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="n">lemma</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">pos</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="s1">'a'</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="s1">'s'</span><span class="p">)</span>

        <span class="c1"># Return the synset object.</span>
        <span class="k">return</span> <span class="n">synset</span></div>

    <span class="k">def</span> <span class="nf">_data_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return an open file pointer for the data file for the given</span>
<span class="sd">        part of speech.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s1">'data.</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

<div class="viewcode-block" id="WordNetCorpusReader.synset_from_pos_and_offset"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.synset_from_pos_and_offset">[docs]</a>    <span class="k">def</span> <span class="nf">synset_from_pos_and_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="c1"># Check to see if the synset is in the cache</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>

        <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">data_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">data_file_line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="k">return</span> <span class="n">synset</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">'Use public method synset_from_pos_and_offset() instead'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_synset_from_pos_and_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hack to help people like the readers of</span>
<span class="sd">        http://stackoverflow.com/a/27145655/1709587</span>
<span class="sd">        who were using this function before it was officially a public method</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_synset_from_pos_and_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">):</span>
        <span class="c1"># Construct a new (empty) synset.</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># parse the entry for this synset</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="c1"># parse out the definitions and examples from the gloss</span>
            <span class="n">columns_str</span><span class="p">,</span> <span class="n">gloss</span> <span class="o">=</span> <span class="n">data_file_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'|'</span><span class="p">)</span>
            <span class="n">gloss</span> <span class="o">=</span> <span class="n">gloss</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">definitions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">gloss_part</span> <span class="ow">in</span> <span class="n">gloss</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">';'</span><span class="p">):</span>
                <span class="n">gloss_part</span> <span class="o">=</span> <span class="n">gloss_part</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">gloss_part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'"'</span><span class="p">):</span>
                    <span class="n">synset</span><span class="o">.</span><span class="n">_examples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gloss_part</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'"'</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">definitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gloss_part</span><span class="p">)</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_definition</span> <span class="o">=</span> <span class="s1">'; '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">definitions</span><span class="p">)</span>

            <span class="c1"># split the other info into fields</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">columns_str</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

            <span class="k">def</span> <span class="nf">_next_token</span><span class="p">():</span> <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>

            <span class="c1"># get the offset</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>

            <span class="c1"># determine the lexicographer file name</span>
            <span class="n">lexname_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_lexname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="p">[</span><span class="n">lexname_index</span><span class="p">]</span>

            <span class="c1"># get the part of speech</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>

            <span class="c1"># create Lemma objects for each lemma</span>
            <span class="n">n_lemmas</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lemmas</span><span class="p">):</span>
                <span class="c1"># get the lemma name</span>
                <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="c1"># get the lex_id (used for sense_keys)</span>
                <span class="n">lex_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                <span class="c1"># If the lemma has a syntactic marker, extract it.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">'(.*?)(\(.*\))?$'</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">)</span>
                <span class="n">lemma_name</span><span class="p">,</span> <span class="n">syn_mark</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="c1"># create the lemma object</span>
                <span class="n">lemma</span> <span class="o">=</span> <span class="n">Lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span>
                              <span class="n">lex_id</span><span class="p">,</span> <span class="n">syn_mark</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">_lemma_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

            <span class="c1"># collect the pointer tuples</span>
            <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">):</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="n">lemma_ids_str</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lemma_ids_str</span> <span class="o">==</span> <span class="s1">'0000'</span><span class="p">:</span>
                    <span class="n">synset</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">source_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">target_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">source_lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">source_index</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span>
                    <span class="n">lemma_pointers</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemma_pointers</span>
                    <span class="n">tups</span> <span class="o">=</span> <span class="n">lemma_pointers</span><span class="p">[</span><span class="n">source_lemma_name</span><span class="p">,</span> <span class="n">symbol</span><span class="p">]</span>
                    <span class="n">tups</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">target_index</span><span class="p">))</span>

            <span class="c1"># read the verb frames</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">frame_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame_count</span><span class="p">):</span>
                    <span class="c1"># read the plus sign</span>
                    <span class="n">plus</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                    <span class="k">assert</span> <span class="n">plus</span> <span class="o">==</span> <span class="s1">'+'</span>
                    <span class="c1"># read the frame and lemma number</span>
                    <span class="n">frame_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                    <span class="n">frame_string_fmt</span> <span class="o">=</span> <span class="n">VERB_FRAME_STRINGS</span><span class="p">[</span><span class="n">frame_number</span><span class="p">]</span>
                    <span class="n">lemma_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                    <span class="c1"># lemma number of 00 means all words in the synset</span>
                    <span class="k">if</span> <span class="n">lemma_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">synset</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">frame_string_fmt</span> <span class="o">%</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span>
                            <span class="p">)</span>
                    <span class="c1"># only a specific word in the synset</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">lemma_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">frame_string_fmt</span> <span class="o">%</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span>
                        <span class="p">)</span>

        <span class="c1"># raise a more informative error with line text</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s1">'line </span><span class="si">%r</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_file_line</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="c1"># set sense keys for Lemma objects - note that this has to be</span>
        <span class="c1"># done afterwards so that the relations are available</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">head_lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">similar_tos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">_name</span>
                <span class="n">head_id</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%02d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">_lex_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_id</span> <span class="o">=</span> <span class="s1">''</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">WordNetCorpusReader</span><span class="o">.</span><span class="n">_pos_numbers</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">],</span>
                   <span class="n">lemma</span><span class="o">.</span><span class="n">_lexname_index</span><span class="p">,</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_lex_id</span><span class="p">,</span> <span class="n">head_name</span><span class="p">,</span> <span class="n">head_id</span><span class="p">)</span>
            <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'</span><span class="si">%s%%%d</span><span class="s1">:</span><span class="si">%02d</span><span class="s1">:</span><span class="si">%02d</span><span class="s1">:</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># the canonical name is based on the first lemma</span>
        <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma_name</span><span class="p">][</span><span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
        <span class="n">sense_index</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">sense_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">.</span><span class="si">%02i</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tup</span>

        <span class="k">return</span> <span class="n">synset</span>

    <span class="c1">#############################################################</span>
    <span class="c1"># Retrieve synsets and lemmas.</span>
    <span class="c1">#############################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader.synsets"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.synsets">[docs]</a>    <span class="k">def</span> <span class="nf">synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Load all synsets with a given lemma and part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        If lang is specified, all the synsets associated with the lemma name</span>
<span class="sd">        of that language will be returned.</span>
<span class="sd">        """</span>
        <span class="n">lemma</span> <span class="o">=</span> <span class="n">lemma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">POS_LIST</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span>
                    <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[])]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">synset_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">lemma</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">synset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">of2ss</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">synset_list</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.lemmas"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">"""Return all Lemma objects with a name matching the specified lemma</span>
<span class="sd">        name and part of speech tag. Matches any part of speech tag if none is</span>
<span class="sd">        specified."""</span>

        <span class="n">lemma</span> <span class="o">=</span> <span class="n">lemma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">lemma_obj</span>
                    <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">lemma_obj</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">lemma_obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">lemma</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemmas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">syn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">lemma_obj</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">lemmas</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lemma_obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">lemma</span><span class="p">:</span>
                        <span class="n">lemmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma_obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lemmas</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.all_lemma_names"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.all_lemma_names">[docs]</a>    <span class="k">def</span> <span class="nf">all_lemma_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">"""Return all lemma names for all synsets for the given</span>
<span class="sd">        part of speech tag and language or languages. If pos is</span>
<span class="sd">        not specified, all synsets for all parts of speech will</span>
<span class="sd">        be used."""</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lemma</span> <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemma</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">lemma</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

            <span class="n">lemma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lemma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">lemma</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.all_synsets"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.all_synsets">[docs]</a>    <span class="k">def</span> <span class="nf">all_synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Iterate over all synsets with a given part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span>
        <span class="n">from_pos_and_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span>

        <span class="c1"># generate all synsets for each part of speech</span>
        <span class="k">for</span> <span class="n">pos_tag</span> <span class="ow">in</span> <span class="n">pos_tags</span><span class="p">:</span>
            <span class="c1"># Open the file for reading.  Note that we can not re-use</span>
            <span class="c1"># the file poitners from self._data_file_map here, because</span>
            <span class="c1"># we're defining an iterator, and those file pointers might</span>
            <span class="c1"># be moved while we're not looking.</span>
            <span class="k">if</span> <span class="n">pos_tag</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">pos_tag</span> <span class="o">=</span> <span class="n">ADJ</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s1">'data.</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">]</span>
            <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># generate synsets for each line in the POS file</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">]:</span>
                            <span class="c1"># See if the synset is cached</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Otherwise, parse the line</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">from_pos_and_line</span><span class="p">(</span><span class="n">pos_tag</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                            <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>

                        <span class="c1"># adjective satellites are in the same file as</span>
                        <span class="c1"># adjectives so only yield the synset if it's actually</span>
                        <span class="c1"># a satellite</span>
                        <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">synset</span>

                        <span class="c1"># for all other POS tags, yield all synsets (this means</span>
                        <span class="c1"># that adjectives also include adjective satellites)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">synset</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

            <span class="c1"># close the extra file handle we opened</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.words"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">"""return lemmas of the given language as list of words"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_lemma_names</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.license"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.license">[docs]</a>    <span class="k">def</span> <span class="nf">license</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'eng'</span><span class="p">):</span>
        <span class="sd">"""Return the contents of LICENSE (for omw)</span>
<span class="sd">           use lang=lang to get the license for an individual language"""</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"LICENSE"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">/LICENSE"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lang</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'omw'</span><span class="p">:</span>
            <span class="c1"># under the assumption you don't mean Omwunra-Toqura</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"LICENSE"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
                <span class="s2">"Cannot determine license for user-provided tab file"</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"Language is not supported."</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.readme"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.readme">[docs]</a>    <span class="k">def</span> <span class="nf">readme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'omw'</span><span class="p">):</span>
        <span class="sd">"""Return the contents of README (for omw)</span>
<span class="sd">           use lang=lang to get the readme for an individual language"""</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"README"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">/README"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lang</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'omw'</span><span class="p">:</span>
            <span class="c1"># under the assumption you don't mean Omwunra-Toqura</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"README"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"No README for user-provided tab file"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"Language is not supported."</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.citation"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.citation">[docs]</a>    <span class="k">def</span> <span class="nf">citation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">'omw'</span><span class="p">):</span>
        <span class="sd">"""Return the contents of citation.bib file (for omw)</span>
<span class="sd">           use lang=lang to get the citation for an individual language"""</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"citation.bib"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">/citation.bib"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lang</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">'omw'</span><span class="p">:</span>
            <span class="c1"># under the assumption you don't mean Omwunra-Toqura</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"citation.bib"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"citation not known for user-provided tab file"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">"Language is not supported."</span><span class="p">)</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Misc</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.lemma_count"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lemma_count">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">):</span>
        <span class="sd">"""Return the frequency count for this Lemma"""</span>
        <span class="c1"># Currently, count is only work for English</span>
        <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_lang</span> <span class="o">!=</span> <span class="s1">'eng'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># open the count file if we haven't already</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'cntlist.rev'</span><span class="p">)</span>
        <span class="c1"># find the key in the counts file and return the count</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span><span class="p">,</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">' '</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.path_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lch_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.wup_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>
    <span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.res_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.jcn_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lin_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>
    <span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="c1">#############################################################</span>
    <span class="c1"># Morphy</span>
    <span class="c1">#############################################################</span>
    <span class="c1"># Morphy, adapted from Oliver Steele's pywordnet</span>
<div class="viewcode-block" id="WordNetCorpusReader.morphy"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.morphy">[docs]</a>    <span class="k">def</span> <span class="nf">morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Find a possible base form for the given form, with the given</span>
<span class="sd">        part of speech, by checking WordNet's list of exceptional</span>
<span class="sd">        forms, and by recursively stripping affixes for this part of</span>
<span class="sd">        speech until a form in WordNet is found.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy('dogs'))</span>
<span class="sd">        dog</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy('churches'))</span>
<span class="sd">        church</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy('aardwolves'))</span>
<span class="sd">        aardwolf</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy('abaci'))</span>
<span class="sd">        abacus</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy('hardrock', wn.ADV)</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy('book', wn.NOUN))</span>
<span class="sd">        book</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy('book', wn.ADJ)</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">morphy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">POS_LIST</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="p">)</span>

        <span class="c1"># get the first one we find</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">analyses</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">NOUN</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'s'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ses'</span><span class="p">,</span> <span class="s1">'s'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ves'</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'xes'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'zes'</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ches'</span><span class="p">,</span> <span class="s1">'ch'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'shes'</span><span class="p">,</span> <span class="s1">'sh'</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'men'</span><span class="p">,</span> <span class="s1">'man'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ies'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">)],</span>
        <span class="n">VERB</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'s'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ies'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'es'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'es'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'ed'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ed'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ing'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'ing'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)],</span>
        <span class="n">ADJ</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'er'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="p">(</span><span class="s1">'est'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="p">(</span><span class="s1">'er'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'est'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">)],</span>
        <span class="n">ADV</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">ADJ</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># from jordanbg:</span>
        <span class="c1"># Given an original string x</span>
        <span class="c1"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="c1"># 2. Return all that are in the database</span>
        <span class="c1"># 3. If there are no matches, keep applying rules until you either</span>
        <span class="c1">#    find a match or you can't go any further</span>

        <span class="n">exceptions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">form</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new</span>
                    <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span>
                    <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">substitutions</span>
                    <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">old</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">form</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">form</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
                            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># 0. Check the exception lists</span>
        <span class="k">if</span> <span class="n">check_exceptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">exceptions</span><span class="p">[</span><span class="n">form</span><span class="p">])</span>

        <span class="c1"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">([</span><span class="n">form</span><span class="p">])</span>

        <span class="c1"># 2. Return all that are in the database (and check the original too)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">forms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="c1"># 3. If there are no matches, keep applying rules until we find a match</span>
        <span class="k">while</span> <span class="n">forms</span><span class="p">:</span>
            <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">results</span>

        <span class="c1"># Return an empty list if we can't find anything</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1">#############################################################</span>
    <span class="c1"># Create information content from corpus</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.ic"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">weight_senses_equally</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Creates an information content lookup dictionary from a corpus.</span>

<span class="sd">        :type corpus: CorpusReader</span>
<span class="sd">        :param corpus: The corpus from which we create an information</span>
<span class="sd">        content dictionary.</span>
<span class="sd">        :type weight_senses_equally: bool</span>
<span class="sd">        :param weight_senses_equally: If this is True, gives all</span>
<span class="sd">        possible senses equal weight rather than dividing by the</span>
<span class="sd">        number of possible senses.  (If a word has 3 synses, each</span>
<span class="sd">        sense gets 0.3333 per appearance when this is False, 1.0 when</span>
<span class="sd">        it is true.)</span>
<span class="sd">        :param smoothing: How much do we smooth synset counts (default is 1.0)</span>
<span class="sd">        :type smoothing: float</span>
<span class="sd">        :return: An information content dictionary</span>
<span class="sd">        """</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">words</span><span class="p">():</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">POS_LIST</span><span class="p">:</span>
            <span class="n">ic</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Initialize the counts with the smoothing value</span>
        <span class="k">if</span> <span class="n">smoothing</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">():</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">_pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">ss</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothing</span>

        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">possible_synsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Distribute weight among possible synsets</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">ww</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">weight_senses_equally</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">possible_synsets</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">_pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                        <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">hh</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="c1"># Add the weight to the root</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="k">return</span> <span class="n">ic</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.custom_lemmas"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetCorpusReader.custom_lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">custom_lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab_file</span><span class="p">,</span> <span class="n">lang</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Reads a custom tab file containing mappings of lemmas in the given</span>
<span class="sd">        language to Princeton WordNet 3.0 synset offsets, allowing NLTK's</span>
<span class="sd">        WordNet functions to then be used with that language.</span>

<span class="sd">        See the "Tab files" section at http://compling.hss.ntu.edu.sg/omw/ for</span>
<span class="sd">        documentation on the Multilingual WordNet tab file format.</span>

<span class="sd">        :param tab_file: Tab file as a file or file-like object</span>
<span class="sd">        :type  lang str</span>
<span class="sd">        :param lang ISO 639-3 code of the language of the tab file</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'lang should be a (3 character) ISO 639-3 code'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">tab_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="c1"># Support byte-stream files (e.g. as returned by Python 2's</span>
                <span class="c1"># open() function) as well as text-stream ones</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">' '</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'#'</span><span class="p">:</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'</span><span class="se">\t</span><span class="s1">'</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div></div>


<span class="c1">######################################################################</span>
<span class="c1"># WordNet Information Content Corpus Reader</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="WordNetICCorpusReader"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetICCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetICCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A corpus reader for the WordNet information content corpus.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">):</span>
        <span class="n">CorpusReader</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">'utf8'</span><span class="p">)</span>

    <span class="c1"># this load function would be more efficient if the data was pickled</span>
    <span class="c1"># Note that we can't use NLTK's frequency distributions because</span>
    <span class="c1"># synsets are overlapping (each instance of a synset also counts</span>
    <span class="c1"># as an instance of its hypernyms)</span>
<div class="viewcode-block" id="WordNetICCorpusReader.ic"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.WordNetICCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">icfile</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Load an information content file from the wordnet_ic corpus</span>
<span class="sd">        and return a dictionary.  This dictionary has just two keys,</span>
<span class="sd">        NOUN and VERB, whose values are dictionaries that map from</span>
<span class="sd">        synsets to information content values.</span>

<span class="sd">        :type icfile: str</span>
<span class="sd">        :param icfile: The name of the wordnet_ic file (e.g. "ic-brown.dat")</span>
<span class="sd">        :return: An information content dictionary</span>
<span class="sd">        """</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">NOUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">VERB</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">icfile</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># skip the header</span>
                <span class="k">continue</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_pos</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"ROOT"</span><span class="p">:</span>
                <span class="c1"># Store root count.</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">ic</span></div></div>


<span class="c1">######################################################################</span>
<span class="c1"># Similarity metrics</span>
<span class="c1">######################################################################</span>

<span class="c1"># TODO: Add in the option to manually add a new root node; this will be</span>
<span class="c1"># useful for verb similarity as there exist multiple verb taxonomies.</span>

<span class="c1"># More information about the metrics is available at</span>
<span class="c1"># http://marimba.d.umn.edu/similarity/measures.html</span>

<div class="viewcode-block" id="path_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.path_similarity">[docs]</a><span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>


<div class="viewcode-block" id="lch_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.lch_similarity">[docs]</a><span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>


<div class="viewcode-block" id="wup_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.wup_similarity">[docs]</a><span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>


<div class="viewcode-block" id="res_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.res_similarity">[docs]</a><span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="jcn_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.jcn_similarity">[docs]</a><span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="lin_similarity"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.lin_similarity">[docs]</a><span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>


<span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">_lcs_ic</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Get the information content of the least common subsumer that has</span>
<span class="sd">    the highest information content value.  If two nodes have no</span>
<span class="sd">    explicit common subsumer, assume that they share an artificial</span>
<span class="sd">    root node that is the hypernym of all explicit roots.</span>

<span class="sd">    :type synset1: Synset</span>
<span class="sd">    :param synset1: First input synset.</span>
<span class="sd">    :type synset2: Synset</span>
<span class="sd">    :param synset2: Second input synset.  Must be the same part of</span>
<span class="sd">    speech as the first synset.</span>
<span class="sd">    :type  ic: dict</span>
<span class="sd">    :param ic: an information content object (as returned by ``load_ic()``).</span>
<span class="sd">    :return: The information content of the two synsets and their most</span>
<span class="sd">    informative subsumer</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">synset1</span><span class="o">.</span><span class="n">_pos</span> <span class="o">!=</span> <span class="n">synset2</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
            <span class="s1">'Computing the least common subsumer requires '</span>
            <span class="s1">'</span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1"> to have the same part of speech.'</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">ic1</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">ic2</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">subsumers</span> <span class="o">=</span> <span class="n">synset1</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">synset2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">information_content</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"&gt; LCS Subsumer by content:"</span><span class="p">,</span> <span class="n">subsumer_ic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">subsumer_ic</span>


<span class="c1"># Utility functions</span>

<div class="viewcode-block" id="information_content"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.information_content">[docs]</a><span class="k">def</span> <span class="nf">information_content</span><span class="p">(</span><span class="n">synset</span><span class="p">,</span> <span class="n">ic</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">icpos</span> <span class="o">=</span> <span class="n">ic</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">'Information content file has no entries for part-of-speech: </span><span class="si">%s</span><span class="s1">'</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">)</span>

    <span class="n">counts</span> <span class="o">=</span> <span class="n">icpos</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_INF</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span> <span class="o">/</span> <span class="n">icpos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<span class="c1"># get the part of speech (NOUN or VERB) from the information content record</span>
<span class="c1"># (each identifier has a 'n' or 'v' suffix)</span>

<span class="k">def</span> <span class="nf">_get_pos</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'n'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NOUN</span>
    <span class="k">elif</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'v'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VERB</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"Unidentified part of speech in WordNet Information Content file "</span>
            <span class="s2">"for field </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">field</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="c1"># unload corpus after tests</span>
<div class="viewcode-block" id="teardown_module"><a class="viewcode-back" href="http://www.nltk.org/api/nltk.corpus.reader.html#nltk.corpus.reader.wordnet.teardown_module">[docs]</a><span class="k">def</span> <span class="nf">teardown_module</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="k">import</span> <span class="n">wordnet</span>
    <span class="n">wordnet</span><span class="o">.</span><span class="n">_unload</span><span class="p">()</span></div>

</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="http://www.nltk.org/news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="http://www.nltk.org/install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="http://www.nltk.org/data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="http://www.nltk.org/contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference internal" href="http://www.nltk.org/api/nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="http://www.nltk.org/search.html" method="get">
                <input type="text" name="q">
                <input type="submit" value="Go">
                <input type="hidden" name="check_keywords" value="yes">
                <input type="hidden" name="area" value="default">
            </form>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="http://www.nltk.org/py-modindex.html" title="Python Module Index">modules</a> |
            <a href="http://www.nltk.org/genindex.html" title="General Index">index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        © Copyright 2017, NLTK Project.
      Last updated on Sep 24, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  
</body></html>